{"ast":null,"code":"import { filter, switchMap, distinctUntilChanged, shareReplay, map } from 'rxjs/operators';\nimport { __decorate, __param, __metadata } from 'tslib';\nimport { ɵɵdefineInjectable, Injectable, InjectionToken, Inject, PLATFORM_ID, NgZone, Optional, ɵɵinject, APP_INITIALIZER, NgModule } from '@angular/core';\nimport { Subject, of } from 'rxjs';\nimport { isPlatformBrowser } from '@angular/common';\nimport * as ɵngcc0 from '@angular/core';\nvar StorageStrategies = /*#__PURE__*/(() => {\n  (function (StorageStrategies) {\n    StorageStrategies[\"Local\"] = \"local_strategy\";\n    StorageStrategies[\"Session\"] = \"session_strategy\";\n    StorageStrategies[\"InMemory\"] = \"in_memory_strategy\";\n  })(StorageStrategies || (StorageStrategies = {}));\n  return StorageStrategies;\n})();\nclass CompatHelper {\n  static isStorageAvailable(storage) {\n    let available = true;\n    try {\n      if (typeof storage === 'object') {\n        storage.setItem('test-storage', 'foobar');\n        storage.removeItem('test-storage');\n      } else available = false;\n    } catch (e) {\n      available = false;\n    }\n    return available;\n  }\n}\nfunction noop() {}\nconst DefaultPrefix = 'ngx-webstorage';\nconst DefaultSeparator = '|';\nconst DefaultIsCaseSensitive = false;\nlet StorageKeyManager = /*#__PURE__*/(() => {\n  class StorageKeyManager {\n    static normalize(raw) {\n      raw = StorageKeyManager.isCaseSensitive ? raw : raw.toLowerCase();\n      return `${StorageKeyManager.prefix}${StorageKeyManager.separator}${raw}`;\n    }\n    static isNormalizedKey(key) {\n      return key.indexOf(StorageKeyManager.prefix + StorageKeyManager.separator) === 0;\n    }\n    static setPrefix(prefix) {\n      StorageKeyManager.prefix = prefix;\n    }\n    static setSeparator(separator) {\n      StorageKeyManager.separator = separator;\n    }\n    static setCaseSensitive(enable) {\n      StorageKeyManager.isCaseSensitive = enable;\n    }\n    static consumeConfiguration(config) {\n      if ('prefix' in config) this.setPrefix(config.prefix);\n      if ('separator' in config) this.setSeparator(config.separator);\n      if ('caseSensitive' in config) this.setCaseSensitive(config.caseSensitive);\n    }\n  }\n  StorageKeyManager.prefix = DefaultPrefix;\n  StorageKeyManager.separator = DefaultSeparator;\n  StorageKeyManager.isCaseSensitive = DefaultIsCaseSensitive;\n  return StorageKeyManager;\n})();\nclass SyncStorage {\n  constructor(strategy) {\n    this.strategy = strategy;\n  }\n  retrieve(key) {\n    let value;\n    this.strategy.get(StorageKeyManager.normalize(key)).subscribe(result => value = typeof result === 'undefined' ? null : result);\n    return value;\n  }\n  store(key, value) {\n    this.strategy.set(StorageKeyManager.normalize(key), value).subscribe(noop);\n    return value;\n  }\n  clear(key) {\n    if (key !== undefined) this.strategy.del(StorageKeyManager.normalize(key)).subscribe(noop);else this.strategy.clear().subscribe(noop);\n  }\n  getStrategyName() {\n    return this.strategy.name;\n  }\n  observe(key) {\n    key = StorageKeyManager.normalize(key);\n    return this.strategy.keyChanges.pipe(filter(changed => changed === null || changed === key), switchMap(() => this.strategy.get(key)), distinctUntilChanged(), shareReplay());\n  }\n}\nclass AsyncStorage {\n  constructor(strategy) {\n    this.strategy = strategy;\n  }\n  retrieve(key) {\n    return this.strategy.get(StorageKeyManager.normalize(key)).pipe(map(value => typeof value === 'undefined' ? null : value));\n  }\n  store(key, value) {\n    return this.strategy.set(StorageKeyManager.normalize(key), value);\n  }\n  clear(key) {\n    return key !== undefined ? this.strategy.del(StorageKeyManager.normalize(key)) : this.strategy.clear();\n  }\n  getStrategyName() {\n    return this.strategy.name;\n  }\n  observe(key) {\n    key = StorageKeyManager.normalize(key);\n    return this.strategy.keyChanges.pipe(filter(changed => changed === null || changed === key), switchMap(() => this.strategy.get(key)), distinctUntilChanged(), shareReplay());\n  }\n}\nlet StrategyCacheService = /*#__PURE__*/(() => {\n  let StrategyCacheService = class StrategyCacheService {\n    constructor() {\n      this.caches = {};\n    }\n    get(strategyName, key) {\n      return this.getCacheStore(strategyName)[key];\n    }\n    set(strategyName, key, value) {\n      this.getCacheStore(strategyName)[key] = value;\n    }\n    del(strategyName, key) {\n      delete this.getCacheStore(strategyName)[key];\n    }\n    clear(strategyName) {\n      this.caches[strategyName] = {};\n    }\n    getCacheStore(strategyName) {\n      if (strategyName in this.caches) return this.caches[strategyName];\n      return this.caches[strategyName] = {};\n    }\n  };\n  StrategyCacheService.ɵfac = function StrategyCacheService_Factory(t) {\n    return new (t || StrategyCacheService)();\n  };\n  StrategyCacheService.ɵprov = ɵɵdefineInjectable({\n    factory: function StrategyCacheService_Factory() {\n      return new StrategyCacheService();\n    },\n    token: StrategyCacheService,\n    providedIn: \"root\"\n  });\n  return StrategyCacheService;\n})();\nconst LOCAL_STORAGE = new InjectionToken('window_local_storage');\nfunction getLocalStorage() {\n  return typeof window !== 'undefined' ? window.localStorage : null;\n}\nconst LocalStorageProvider = {\n  provide: LOCAL_STORAGE,\n  useFactory: getLocalStorage\n};\nconst SESSION_STORAGE = new InjectionToken('window_session_storage');\nfunction getSessionStorage() {\n  return typeof window !== 'undefined' ? window.sessionStorage : null;\n}\nconst SessionStorageProvider = {\n  provide: SESSION_STORAGE,\n  useFactory: getSessionStorage\n};\nclass BaseSyncStorageStrategy {\n  constructor(storage, cache) {\n    this.storage = storage;\n    this.cache = cache;\n    this.keyChanges = new Subject();\n  }\n  get isAvailable() {\n    if (this._isAvailable === undefined) this._isAvailable = CompatHelper.isStorageAvailable(this.storage);\n    return this._isAvailable;\n  }\n  get(key) {\n    let data = this.cache.get(this.name, key);\n    if (data !== undefined) return of(data);\n    try {\n      const item = this.storage.getItem(key);\n      if (item !== null) {\n        data = JSON.parse(item);\n        this.cache.set(this.name, key, data);\n      }\n    } catch (err) {\n      console.warn(err);\n    }\n    return of(data);\n  }\n  set(key, value) {\n    const data = JSON.stringify(value);\n    this.storage.setItem(key, data);\n    this.cache.set(this.name, key, value);\n    this.keyChanges.next(key);\n    return of(value);\n  }\n  del(key) {\n    this.storage.removeItem(key);\n    this.cache.del(this.name, key);\n    this.keyChanges.next(key);\n    return of(null);\n  }\n  clear() {\n    this.storage.clear();\n    this.cache.clear(this.name);\n    this.keyChanges.next(null);\n    return of(null);\n  }\n}\nvar LocalStorageStrategy_1;\nlet LocalStorageStrategy = LocalStorageStrategy_1 = class LocalStorageStrategy extends BaseSyncStorageStrategy {\n  constructor(storage, cache, platformId, zone) {\n    super(storage, cache);\n    this.storage = storage;\n    this.cache = cache;\n    this.platformId = platformId;\n    this.zone = zone;\n    this.name = LocalStorageStrategy_1.strategyName;\n    if (isPlatformBrowser(this.platformId)) this.listenExternalChanges();\n  }\n  listenExternalChanges() {\n    window.addEventListener('storage', event => this.zone.run(() => {\n      if (event.storageArea !== this.storage) return;\n      const key = event.key;\n      if (key !== null) this.cache.del(this.name, event.key);else this.cache.clear(this.name);\n      this.keyChanges.next(key);\n    }));\n  }\n};\nLocalStorageStrategy.ɵfac = function LocalStorageStrategy_Factory(t) {\n  return new (t || LocalStorageStrategy)(ɵngcc0.ɵɵinject(LOCAL_STORAGE), ɵngcc0.ɵɵinject(StrategyCacheService), ɵngcc0.ɵɵinject(PLATFORM_ID), ɵngcc0.ɵɵinject(ɵngcc0.NgZone));\n};\nLocalStorageStrategy.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: LocalStorageStrategy,\n  factory: function (t) {\n    return LocalStorageStrategy.ɵfac(t);\n  }\n});\nLocalStorageStrategy.strategyName = StorageStrategies.Local;\nLocalStorageStrategy.ctorParameters = () => [{\n  type: undefined,\n  decorators: [{\n    type: Inject,\n    args: [LOCAL_STORAGE]\n  }]\n}, {\n  type: StrategyCacheService\n}, {\n  type: undefined,\n  decorators: [{\n    type: Inject,\n    args: [PLATFORM_ID]\n  }]\n}, {\n  type: NgZone\n}];\nLocalStorageStrategy = LocalStorageStrategy_1 = __decorate([__param(0, Inject(LOCAL_STORAGE)), __param(2, Inject(PLATFORM_ID)), __metadata(\"design:paramtypes\", [Object, StrategyCacheService, Object, NgZone])], LocalStorageStrategy);\nvar SessionStorageStrategy_1;\nlet SessionStorageStrategy = SessionStorageStrategy_1 = class SessionStorageStrategy extends BaseSyncStorageStrategy {\n  constructor(storage, cache, platformId, zone) {\n    super(storage, cache);\n    this.storage = storage;\n    this.cache = cache;\n    this.platformId = platformId;\n    this.zone = zone;\n    this.name = SessionStorageStrategy_1.strategyName;\n    if (isPlatformBrowser(this.platformId)) this.listenExternalChanges();\n  }\n  listenExternalChanges() {\n    window.addEventListener('storage', event => this.zone.run(() => {\n      if (event.storageArea !== this.storage) return;\n      const key = event.key;\n      if (event.key !== null) this.cache.del(this.name, event.key);else this.cache.clear(this.name);\n      this.keyChanges.next(key);\n    }));\n  }\n};\nSessionStorageStrategy.ɵfac = function SessionStorageStrategy_Factory(t) {\n  return new (t || SessionStorageStrategy)(ɵngcc0.ɵɵinject(SESSION_STORAGE), ɵngcc0.ɵɵinject(StrategyCacheService), ɵngcc0.ɵɵinject(PLATFORM_ID), ɵngcc0.ɵɵinject(ɵngcc0.NgZone));\n};\nSessionStorageStrategy.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: SessionStorageStrategy,\n  factory: function (t) {\n    return SessionStorageStrategy.ɵfac(t);\n  }\n});\nSessionStorageStrategy.strategyName = StorageStrategies.Session;\nSessionStorageStrategy.ctorParameters = () => [{\n  type: undefined,\n  decorators: [{\n    type: Inject,\n    args: [SESSION_STORAGE]\n  }]\n}, {\n  type: StrategyCacheService\n}, {\n  type: undefined,\n  decorators: [{\n    type: Inject,\n    args: [PLATFORM_ID]\n  }]\n}, {\n  type: NgZone\n}];\nSessionStorageStrategy = SessionStorageStrategy_1 = __decorate([__param(0, Inject(SESSION_STORAGE)), __param(2, Inject(PLATFORM_ID)), __metadata(\"design:paramtypes\", [Object, StrategyCacheService, Object, NgZone])], SessionStorageStrategy);\nvar InMemoryStorageStrategy_1;\nlet InMemoryStorageStrategy = InMemoryStorageStrategy_1 = class InMemoryStorageStrategy {\n  constructor(cache) {\n    this.cache = cache;\n    this.keyChanges = new Subject();\n    this.isAvailable = true;\n    this.name = InMemoryStorageStrategy_1.strategyName;\n  }\n  get(key) {\n    return of(this.cache.get(this.name, key));\n  }\n  set(key, value) {\n    this.cache.set(this.name, key, value);\n    this.keyChanges.next(key);\n    return of(value);\n  }\n  del(key) {\n    this.cache.del(this.name, key);\n    this.keyChanges.next(key);\n    return of(null);\n  }\n  clear() {\n    this.cache.clear(this.name);\n    this.keyChanges.next(null);\n    return of(null);\n  }\n};\nInMemoryStorageStrategy.ɵfac = function InMemoryStorageStrategy_Factory(t) {\n  return new (t || InMemoryStorageStrategy)(ɵngcc0.ɵɵinject(StrategyCacheService));\n};\nInMemoryStorageStrategy.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: InMemoryStorageStrategy,\n  factory: function (t) {\n    return InMemoryStorageStrategy.ɵfac(t);\n  }\n});\nInMemoryStorageStrategy.strategyName = StorageStrategies.InMemory;\nInMemoryStorageStrategy.ctorParameters = () => [{\n  type: StrategyCacheService,\n  decorators: [{\n    type: Inject,\n    args: [StrategyCacheService]\n  }]\n}];\nInMemoryStorageStrategy = InMemoryStorageStrategy_1 = __decorate([__param(0, Inject(StrategyCacheService)), __metadata(\"design:paramtypes\", [StrategyCacheService])], InMemoryStorageStrategy);\nconst STORAGE_STRATEGIES = new InjectionToken('STORAGE_STRATEGIES');\nconst Strategies = [{\n  provide: STORAGE_STRATEGIES,\n  useClass: InMemoryStorageStrategy,\n  multi: true\n}, {\n  provide: STORAGE_STRATEGIES,\n  useClass: LocalStorageStrategy,\n  multi: true\n}, {\n  provide: STORAGE_STRATEGIES,\n  useClass: SessionStorageStrategy,\n  multi: true\n}];\nconst StorageStrategyStubName = 'stub_strategy';\nclass StorageStrategyStub {\n  constructor(name) {\n    this.keyChanges = new Subject();\n    this.store = {};\n    this._available = true;\n    this.name = name || StorageStrategyStubName;\n  }\n  get isAvailable() {\n    return this._available;\n  }\n  get(key) {\n    return of(this.store[key]);\n  }\n  set(key, value) {\n    this.store[key] = value;\n    this.keyChanges.next(key);\n    return of(value);\n  }\n  del(key) {\n    delete this.store[key];\n    this.keyChanges.next(key);\n    return of(null);\n  }\n  clear() {\n    this.store = {};\n    this.keyChanges.next(null);\n    return of(null);\n  }\n}\nclass StorageStub {\n  constructor() {\n    this.store = {};\n  }\n  get length() {\n    return Object.keys(this.store).length;\n  }\n  clear() {\n    this.store = {};\n  }\n  getItem(key) {\n    return this.store[key] || null;\n  }\n  key(index) {\n    return Object.keys(this.store)[index];\n  }\n  removeItem(key) {\n    delete this.store[key];\n  }\n  setItem(key, value) {\n    this.store[key] = value;\n  }\n}\nvar StrategyIndex_1;\nconst InvalidStrategyError = 'invalid_strategy';\nlet StrategyIndex = StrategyIndex_1 = class StrategyIndex {\n  constructor(strategies) {\n    this.strategies = strategies;\n    this.registration$ = new Subject();\n    if (!strategies) strategies = [];\n    this.strategies = strategies.reverse().map((strategy, index, arr) => strategy.name).map((name, index, arr) => arr.indexOf(name) === index ? index : null).filter(index => index !== null).map(index => strategies[index]);\n  }\n  static get(name) {\n    if (!this.isStrategyRegistered(name)) throw Error(InvalidStrategyError);\n    let strategy = this.index[name];\n    if (!strategy.isAvailable) {\n      strategy = this.index[StorageStrategies.InMemory];\n    }\n    return strategy;\n  }\n  static set(name, strategy) {\n    this.index[name] = strategy;\n  }\n  static clear(name) {\n    if (name !== undefined) delete this.index[name];else this.index = {};\n  }\n  static isStrategyRegistered(name) {\n    return name in this.index;\n  }\n  static hasRegistredStrategies() {\n    return Object.keys(this.index).length > 0;\n  }\n  getStrategy(name) {\n    return StrategyIndex_1.get(name);\n  }\n  indexStrategies() {\n    this.strategies.forEach(strategy => this.register(strategy.name, strategy));\n  }\n  indexStrategy(name, overrideIfExists = false) {\n    if (StrategyIndex_1.isStrategyRegistered(name) && !overrideIfExists) return StrategyIndex_1.get(name);\n    const strategy = this.strategies.find(strategy => strategy.name === name);\n    if (!strategy) throw new Error(InvalidStrategyError);\n    this.register(name, strategy, overrideIfExists);\n    return strategy;\n  }\n  register(name, strategy, overrideIfExists = false) {\n    if (!StrategyIndex_1.isStrategyRegistered(name) || overrideIfExists) {\n      StrategyIndex_1.set(name, strategy);\n      this.registration$.next(name);\n    }\n  }\n};\nStrategyIndex.ɵfac = function StrategyIndex_Factory(t) {\n  return new (t || StrategyIndex)(ɵngcc0.ɵɵinject(STORAGE_STRATEGIES, 8));\n};\nStrategyIndex.index = {};\nStrategyIndex.ctorParameters = () => [{\n  type: Array,\n  decorators: [{\n    type: Optional\n  }, {\n    type: Inject,\n    args: [STORAGE_STRATEGIES]\n  }]\n}];\nStrategyIndex.ɵprov = ɵɵdefineInjectable({\n  factory: function StrategyIndex_Factory() {\n    return new StrategyIndex(ɵɵinject(STORAGE_STRATEGIES, 8));\n  },\n  token: StrategyIndex,\n  providedIn: \"root\"\n});\nStrategyIndex = StrategyIndex_1 = __decorate([__param(0, Optional()), __param(0, Inject(STORAGE_STRATEGIES)), __metadata(\"design:paramtypes\", [Array])], StrategyIndex);\nclass LocalStorageService extends SyncStorage {}\nfunction buildService(index) {\n  const strategy = index.indexStrategy(StorageStrategies.Local);\n  return new SyncStorage(strategy);\n}\nconst LocalStorageServiceProvider = {\n  provide: LocalStorageService,\n  useFactory: buildService,\n  deps: [StrategyIndex]\n};\nclass SessionStorageService extends SyncStorage {}\nfunction buildService$1(index) {\n  const strategy = index.indexStrategy(StorageStrategies.Session);\n  return new SyncStorage(strategy);\n}\nconst SessionStorageServiceProvider = {\n  provide: SessionStorageService,\n  useFactory: buildService$1,\n  deps: [StrategyIndex]\n};\nclass DecoratorBuilder {\n  static buildSyncStrategyDecorator(strategyName, prototype, propName, key, defaultValue = null) {\n    const rawKey = key || propName;\n    let storageKey;\n    Object.defineProperty(prototype, propName, {\n      get: function () {\n        let value;\n        StrategyIndex.get(strategyName).get(getKey()).subscribe(result => value = result);\n        return value === undefined ? defaultValue : value;\n      },\n      set: function (value) {\n        StrategyIndex.get(strategyName).set(getKey(), value).subscribe(noop);\n      }\n    });\n    function getKey() {\n      if (storageKey !== undefined) return storageKey;\n      return storageKey = StorageKeyManager.normalize(rawKey);\n    }\n  }\n}\nfunction LocalStorage(key, defaultValue) {\n  return function (prototype, propName) {\n    DecoratorBuilder.buildSyncStrategyDecorator(StorageStrategies.Local, prototype, propName, key, defaultValue);\n  };\n}\nfunction SessionStorage(key, defaultValue) {\n  return function (prototype, propName) {\n    DecoratorBuilder.buildSyncStrategyDecorator(StorageStrategies.Session, prototype, propName, key, defaultValue);\n  };\n}\nconst Services = [LocalStorageServiceProvider, SessionStorageServiceProvider];\nvar NgxWebstorageModule_1;\nconst LIB_CONFIG = new InjectionToken('ngx_webstorage_config');\nfunction appInit(index) {\n  index.indexStrategies();\n  return () => StrategyIndex.index;\n}\nlet NgxWebstorageModule = NgxWebstorageModule_1 = class NgxWebstorageModule {\n  constructor(index, config) {\n    if (config) StorageKeyManager.consumeConfiguration(config);else console.error('NgxWebstorage : Possible misconfiguration (The forRoot method usage is mandatory since the 3.0.0)');\n  }\n  static forRoot(config = {}) {\n    return {\n      ngModule: NgxWebstorageModule_1,\n      providers: [{\n        provide: LIB_CONFIG,\n        useValue: config\n      }, LocalStorageProvider, SessionStorageProvider, ...Services, ...Strategies, {\n        provide: APP_INITIALIZER,\n        useFactory: appInit,\n        deps: [StrategyIndex],\n        multi: true\n      }]\n    };\n  }\n};\nNgxWebstorageModule.ɵfac = function NgxWebstorageModule_Factory(t) {\n  return new (t || NgxWebstorageModule)(ɵngcc0.ɵɵinject(StrategyIndex), ɵngcc0.ɵɵinject(LIB_CONFIG, 8));\n};\nNgxWebstorageModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n  type: NgxWebstorageModule\n});\nNgxWebstorageModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\nNgxWebstorageModule.ctorParameters = () => [{\n  type: StrategyIndex\n}, {\n  type: undefined,\n  decorators: [{\n    type: Optional\n  }, {\n    type: Inject,\n    args: [LIB_CONFIG]\n  }]\n}];\nNgxWebstorageModule = NgxWebstorageModule_1 = __decorate([__param(1, Optional()), __param(1, Inject(LIB_CONFIG)), __metadata(\"design:paramtypes\", [StrategyIndex, Object])], NgxWebstorageModule);\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/*\n * Public API Surface of ngx-webstorage\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { AsyncStorage, CompatHelper, InMemoryStorageStrategy, InvalidStrategyError, LIB_CONFIG, LOCAL_STORAGE, LocalStorage, LocalStorageService, LocalStorageStrategy, NgxWebstorageModule, SESSION_STORAGE, STORAGE_STRATEGIES, SessionStorage, SessionStorageService, SessionStorageStrategy, StorageStrategies, StorageStrategyStub, StorageStrategyStubName, StorageStub, StrategyCacheService, StrategyIndex, SyncStorage, appInit, getLocalStorage as ɵa, LocalStorageProvider as ɵb, getSessionStorage as ɵc, SessionStorageProvider as ɵd, Strategies as ɵe, buildService as ɵf, LocalStorageServiceProvider as ɵg, buildService$1 as ɵh, SessionStorageServiceProvider as ɵi, BaseSyncStorageStrategy as ɵj, STORAGE_STRATEGIES as ɵl, Services as ɵn };\n\n//# sourceMappingURL=ngx-webstorage.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}